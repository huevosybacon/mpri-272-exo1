Require Import FormalSystem Translation Classical.

(*--------------------------------------*)
(*Equality and Peano and Heyting Arithmetic*)

Notation "x ≈ y" := (Atom (x=y))
                     (at level 99).

(*Question 4.1.1*)
(*A family of theories of equality, indexed over Type*)
Inductive E (A:Type) : form -> Prop :=
| E_refl (x:A)      : E A (x≈x) (*reflexivity schema*)
| E_symm (x y:A)    : E A ((x≈y) ⇒ (y≈x)) (*symmetry schema*)
| E_trans (x y z:A) : E A ((x≈y) ⇒ (y≈z) ⇒ (x≈z)). (*transitivity schema*)



(*The previous (possibly infinite) axiomatisation using schemata is of course equivalent to the one below, with three axioms, but the one below is much more difficult to work with formally*)
Inductive E' (A:Type) : form -> Prop :=
| E'_refl : E' A (All (fun x:A => x≈x)) (*reflexivity axiom*)
| E'_symm : E' A (All (fun x:A => 
                       All (fun y:A =>
                              (x≈y) ⇒ (y≈x)))) (*symmetry axiom*)
| E'_trans : E' A (All (fun x:A =>
                        All (fun y:A =>
                               All (fun z:A =>
                                      (x≈y) ⇒ (y≈z) ⇒ (x≈z))))).
                                                  (*transitivity axiom*)


(*Equi-provability of E and E'*)
Lemma EE' A f :
  (E A f) -> (E' A ⊢ f) .
Proof.
  intro H.
  induction H.
  - apply (all_e _ (fun x:A => x≈x)).
    apply ax. constructor.
  - apply (all_e _ (fun y:A =>
                      (x≈y) ⇒ (y≈x))).
    apply (all_e _ (fun x:A => 
                      All (fun y:A =>
                              (x≈y) ⇒ (y≈x)))).
    apply ax. constructor.
  - apply (all_e _ (fun z:A =>
                      (x≈y) ⇒ (y≈z) ⇒ (x≈z))).
    apply (all_e _ (fun y:A =>
                      All (fun z:A =>
                             (x≈y) ⇒ (y≈z) ⇒ (x≈z)))).
    apply (all_e _ (fun x:A =>
                      All (fun y:A =>
                             All (fun z:A =>
                                    (x≈y) ⇒ (y≈z) ⇒ (x≈z))))).
    apply ax. constructor.
Qed.


Lemma E'E A f :
  (E' A f) -> (E A ⊢ f) .
Proof.
  intro H. induction H; apply all_i; intro.
  + apply ax. constructor.
  + apply all_i. intro. apply ax. constructor.
  + apply all_i. intro. apply all_i. intro. apply ax. constructor.
Qed.

Theorem EE'_eq A f :
  (E A ⊢ f) <-> (E' A ⊢ f).
Proof.
  split; intro H.
  - apply (deriv_substitution (E A)).
    + assumption.
    + apply EE'.
  - apply (deriv_substitution (E' A)).
    + assumption.
    + apply E'E.
Qed.




(*Question 4.1.2*)
(*The theory of arithmetic (PA:="Peano's axiom"). PA3 and PA4 are presented as schemata. PA5 is necessarily a schema*)
Inductive A : form -> Prop :=
| PA3 n   : A (!(0 ≈ S n))
| PA4 m n : A (S(m) ≈ S(n) ⇒ m≈n)
| PA5 P   : A (P 0 ⇒
                 (All (fun k => P k ⇒ P (S k)) ⇒
                      All (fun k => P k)))
.


(*Question 4.1.3*)
(*The definitional equalities generated by the definitions in Coq of the terms (+,*:nat → nat) carry over to the theories (E nat) and (E' nat) via reflexivity. The (non-judgmental) propositional equalities do not carry over. We give one example of each.*)
Check plus_Sn_m.
Lemma plusSnm n m :
  E nat ⊢ (S n +  m ≈ S (n + m)).
Proof.
  apply ax. constructor.
Qed.

Check plus_n_Sm.
Lemma plusnSm n m :
  E nat ⊢ (n + S m ≈ S (n + m)).
Proof.
  apply ax. Fail constructor.
Abort.



(*Peano and Heyting Arithmetic*)
Definition PA := A ⋃ (E nat) ⋃ classic.
Definition HA := A ⋃ (E nat).
Definition deriv_PA L f := L ⋃ PA ⊢ f.
Definition deriv_HA L f := L ⋃ HA ⊢ f.
Notation "L ⊢ₚ f " := (deriv_PA L f)
                        (at level 99).
Notation "L ⊢ₕ f " := (deriv_HA L f)
                        (at level 99).


(*Question 4.2.1*)
(*Preservation of provability, in E A, of the translation of the axioms of E A*)
Lemma E_nnt A f :
  E A f -> E A ⊢ nnt f.
Proof.
  intro H. induction H; simpl in *.
  - apply nnt_helper.
    apply ax. left. constructor.
  - apply imp_i, imp_i, (imp_e _ (!(x ≈ y))).
    + apply ax. left. right. reflexivity.
    + apply imp_i, (imp_e _ (y≈x)).
      * apply ax. left. right. reflexivity.
      * apply (imp_e _ (x≈y)); apply ax;
          [ left; left; left; constructor | right; reflexivity].
  - do 3 apply imp_i. apply (imp_e _ (!(y≈z))).
    + apply ax. left. right. reflexivity.
    + apply imp_i. apply (imp_e _ (!(x≈y))).
      * apply ax. left. left. left. right. reflexivity.
      * apply imp_i, (imp_e _ (x≈z)).
        apply ax; do 2 left; right; reflexivity.
        apply (imp_e _ (y≈z));[apply (imp_e _ (x≈y)); apply ax;
                               [do 5 left; constructor | right; reflexivity]
                              | apply ax; left; right; reflexivity].
Qed.

(*The same for A*)
Lemma A_nnt f :
  A f -> A ⊢ nnt f.
Proof.
  intro H. induction H; simpl in *.
  - apply nnt_helper. apply ax; left; constructor.
  - apply imp_i, imp_i, (imp_e _ (!(S m≈S n))).
    + apply ax; left; right; reflexivity.
    + apply imp_i, (imp_e _ (m≈n)).
      * apply ax; left; right; reflexivity.
      * apply (imp_e _ (S m≈S n)); apply ax; [do 3 left; constructor
                                             |right; reflexivity].
  - apply ax, (PA5 (fun x => nnt (P x))).
Qed.



(*Question 4.2.2*)
(*The translation of a derivable judgment L ⊢ₚ f in PA is a derivable judgment of HA*)
Lemma nnt_ha L f:
  L ⊢ₚ f ->
  nnt_ctx L ⊢ₕ nnt f.
Proof.
  intro H.
  assert (nnt_ctx (L ⋃ PA) ⊢ nnt f).
  - apply nnt_soundness. assumption.
  - apply (deriv_substitution (nnt_ctx (L ⋃ PA))).
    + assumption.
    + clear H H0. intros g H. destruct H as [h [H H']]. rewrite H'.
      clear H' g. case H.
      * intro. apply (deriv_substitution (nnt_ctx L)).
        -- apply nnt_soundness, ax; assumption.
        -- intros. apply ax. left. assumption.
      * intro H1. case H1.
        -- intro. case H0.
           ++ intro. apply (deriv_substitution A).
              ** apply A_nnt; assumption.
              ** intros. apply ax; right; left; assumption.
           ++ intro. apply (deriv_substitution (E nat)).
              --- apply E_nnt; assumption.
              --- intros. apply ax; right; right; assumption.
        -- intro. apply c_nnt; assumption.
Qed.


(*Fin*)